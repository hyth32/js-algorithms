## Нотация O

> Сложность выполнения операции, показывающая скорость изменения времени для выполнения операции в зависимости от кол-ва
> элементов операции

- O(1) - константное время (обращение по индексу к элементам массива). Вне зависимости от кол-ва элементов в массиве
  доступ осуществляется мгновенно
- O(n) - время выполнения зависит от количества элементов

## Массивы

- Одномерные
- Многомерные
- Статические (изначально заданная длина) - операции вставки и удаления не поддерживаются
- Динамические - выделяется область памяти, при добавлении элемента в конец массива O(1), но когда памяти под новые
  элементы нет, массив придется создавать в другом месте в памяти, где места хватит на все элементы, соответственно,
  если мы воссоздаем его заново, времени понадобится O(n) в зависимости от кол-ва элементов. То же самое со вставкой в
  начало из-за сдвига массива вправо

## Бинарное дерево

почитать что такое красно-черное, авл

1. Должно соблюдаться условие, что дерево должно быть отсортированным - слева от родителя элементы меньше родителя,
   справа
   больше.
2. Поиск/вставка/удаление O(log(n)) - на каждой итерации отсеивается половина элементов

## Красно-чёрные деревья

> Одна из разновидностей сбалансированных двоичных деревьев поиска. Они являются эффективной структурой данных для
> операций добавления, удаления и поиска элементов, так как обеспечивают гарантированный логарифмический худший случай
> времени выполнения для этих операций.

**Основные свойства красно-чёрных деревьев:**

1. Каждый узел является либо красным, либо черным.
2. Корень и листья (nil-узлы) дерева являются черными.
3. Красный узел не может иметь красного потомка.
4. Для каждого узла все простые пути от него до листьев содержат одинаковое количество черных узлов. Это свойство
   гарантирует, что самый длинный путь в дереве не более чем в два раза длиннее самого короткого.

**Вставка (Insertion):**

- В худшем случае: O(log n)
- В среднем случае: O(log n)

**Удаление (Deletion):**

- В худшем случае: O(log n)
- В среднем случае: O(log n)

**Поиск (Search):**

- В худшем случае: O(log n)
- В среднем случае: O(log n)

## АВЛ дерево

> Сбалансированное двоичное дерево поиска, которое гарантирует логарифмическое время выполнения основных операций (
> вставка, удаление, поиск) в худшем случае. Основная идея состоит в том, чтобы поддерживать балансировку дерева,
> обеспечивая, чтобы разница высот поддеревьев не превышала 1.

**Основные свойства АВЛ-деревьев:**

1. Сбалансированность: Каждый узел имеет сбалансированное поддерево, т.е., разница высоты левого и правого поддеревьев
   для
   каждого узла ограничена значением 1.
2. Эффективность: Благодаря сбалансированности, операции вставки, удаления и поиска в АВЛ-деревьях выполняются за
   логарифмическое время в худшем случае, что делает их очень эффективными для использования в приложениях, где
   требуется
   быстрый доступ к данным.
3. Сложность операций: Вставка, удаление и поиск элементов в АВЛ-деревьях имеют сложность O(log n), где n - количество
   элементов в дереве.

4. Небольшой overhead: Хранение дополнительной информации о высоте узла может создать небольшой overhead по сравнению с
обычными двоичными деревьями поиска, но это обеспечивает более быстрый доступ к данным.

**Вставка (Insertion):**
    - В худшем случае: O(log n)

**Удаление (Deletion):**
    - В худшем случае: O(log n)

**Поиск (Search):**
    - В худшем случае: O(log n)

## Сортировки

- Сортировка выбором - пробегаемся по массиву, ищем максимальный или минимальный элемент, поднимаем его, и делаем то же
  самое с массивом длиной length - 1
- Сложность - O(n^2)
- Пузырьковая сортировка - пробегаемся по массиву, меняем местами curr и next элемент при каждой итерации,
  при этом сокращаем длину массива на количество пройденных итераций
- Быстрая сортировка

  **Сложность по времени:**
    - Худшее время: O(n ^ 2) - каждый раз, выбирая опорный элемент, натыкаемся на самый большой или меньший
    - Среднее время O(n log n)
    - Лучшее время O(n)
      **Затраты по памяти:**
    - O(n)

- Сортировка слиянием
  **Сложность по времени:**
    - Худшее время: O(n log n)
    - Среднее время: O(n log n)
    - Лучшее время: O(n log n)

## Связные списки

> В отличие от массивов, хранят элементы в памяти разрозненно, т.е. в случае массива
> при нехватке выделенной памяти он перезаписывается с добавлением памяти, здесь такого нет.
> Элементы связаны между собой указателями. Это плюс для операций вставки или удаления, но минус при чтении,
> потому что мы не имеем по индексу доступ за константное время O(1). Чтобы получить элемент по индексу,
> нам приходится до этого индекса пройтись по всем элементам, взять указатель и проитерироваться до нужного O(n).
> Стоит использовать, когда операция чтения реже, чем запись или удаление

## Стек

> LIFO (Last-in-first-out).

## Очередь

> LILO (Last-in-last-out)

## Хэш-таблица

> Массив связных списков, где элементы массива хранятся в бакетах.
>
> Работает на основе хэш-функции, которая принимает примитивы/объекты и возвращает int (хэш)
>
> Время работы - O(1)
>
> Коллизия - несколько объектов не имеют одинаковый хэш-код, но индекс один и тот же. К ним доступ осуществляется
> за O(n) время из-за итерации по связному списку и проверке хэш-кода