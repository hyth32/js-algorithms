## Нотация O

> Сложность выполнения операции, показывающая скорость изменения времени для выполнения операции в зависимости от кол-ва
> элементов операции

- O(1) - константное время (обращение по индексу к элементам массива). Вне зависимости от кол-ва элементов в массиве
  доступ осуществляется мгновенно
- O(n) - время выполнения зависит от количества элементов

## Массивы

- Одномерные
- Многомерные
- Статические (изначально заданная длина) - операции вставки и удаления не поддерживаются
- Динамические - выделяется область памяти, при добавлении элемента в конец массива O(1), но когда памяти под новые
  элементы нет, массив придется создавать в другом месте в памяти, где места хватит на все элементы, соответственно,
  если мы воссоздаем его заново, времени понадобится O(n) в зависимости от кол-ва элементов. То же самое со вставкой в
  начало из-за сдвига массива вправо

## Бинарное дерево

почитать что такое красно-черное, авл

1. Должно соблюдаться условие, что дерево должно быть отсортированным - слева от родителя элементы меньше родителя,
   справа
   больше.
2. Поиск/вставка/удаление O(log(n)) - на каждой итерации отсеивается половина элементов

## Сортировки

- Сортировка выбором - пробегаемся по массиву, ищем максимальный или минимальный элемент, поднимаем его, и делаем то же
  самое с массивом длиной length - 1
- Сложность - O(n^2)
- Пузырьковая сортировка - пробегаемся по массиву, меняем местами curr и next элемент при каждой итерации,
  при этом сокращаем длину массива на количество пройденных итераций
- Быстрая сортировка

  **Сложность по времени:**
    - Худшее время: O(n ^ 2) - каждый раз, выбирая опорный элемент, натыкаемся на самый большой или меньший
    - Среднее время O(n log n)
    - Лучшее время O(n)
  **Затраты по памяти:**
    - O(n)

- Сортировка слиянием
  **Сложность по времени:**
  - Худшее время: O(n log n)
  - Среднее время: O(n log n)
  - Лучшее время: O(n log n)

## Связные списки

> В отличие от массивов, хранят элементы в памяти разрозненно, т.е. в случае массива
> при нехватке выделенной памяти он перезаписывается с добавлением памяти, здесь такого нет.
> Элементы связаны между собой указателями. Это плюс для операций вставки или удаления, но минус при чтении,
> потому что мы не имеем по индексу доступ за константное время O(1). Чтобы получить элемент по индексу,
> нам приходится до этого индекса пройтись по всем элементам, взять указатель и проитерироваться до нужного O(n).
> Стоит использовать, когда операция чтения реже, чем запись или удаление

## Стек

> LIFO (Last-in-first-out).

## Очередь

> LILO (Last-in-last-out)

## Хэш-таблица

> Массив связных списков, где элементы массива хранятся в бакетах.
> 
> Работает на основе хэш-функции, которая принимает примитивы/объекты и возвращает int (хэш)
> 
> Время работы - O(1)
> 
> Коллизия - несколько объектов не имеют одинаковый хэш-код, но индекс один и тот же. К ним доступ осуществляется
> за O(n) время из-за итерации по связному списку и проверке хэш-кода